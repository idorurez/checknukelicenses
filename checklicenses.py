#!/usr/bin/env python

import unittest
import urllib
import urllib2
import datetime
import operator

from collections import defaultdict
from bs4 import BeautifulSoup
from pprint import pprint

import jaunt.framework.app
import jaunt.logging


class App(jaunt.framework.app.App):
    """ Tool to check licenses and usage """

    def preflight(self, *args, **kwargs):
        """ Check for proper environment configuration. """
        super(App, self).preflight(*args, **kwargs)

    def configureParser(self, prog, *args, **kwargs):
        """ Configure the argparse self.parser object.
			See: https://docs.python.org/2/library/argparse.html"""
        super(App, self).configureParser(prog, *args, **kwargs)

    def validateNamespace(self, prog, *args, **kwargs):
        """ Configure the self.namespace object generated by argparse.
			Raise exceptions, for example, for complex mutual-exclusion
			requirements.  Add new attributes to the object based on
			collections of parsed arguments. """
        super(App, self).validateNamespace(None, *args, **kwargs)

    def parseLicenses(self, table, tracklist):
        """ takes in an html table representing products we're licensing
			and their respective license allotments

			returns a dictionary of keys with a aggregate
			sum of everything we want to track
		"""

        tablerows = table.find_all('tr')
        header = tablerows[0].find_all('td')
        tablebody = tablerows[1:]

        # get header
        header = map(self.stripHtml, header)

        # find positions of what we want to find
        pos = map(lambda x: header.index(x), tracklist)

        row_length = len(pos)
        default_list = [0] * row_length
        licenses = defaultdict(lambda: default_list)

        for row in tablebody:
            cols = row.find_all('td')
            product = str(cols[0].string)  # first item is product

            # make sure we're not seeing a string value for a tracked columns
            tracked = list(map(lambda i: int(cols[i].string.encode('utf-8')) if cols[i].string.isdigit() else cols[i].string.encode('utf-8'),
                               pos))  # get the list of all tracked
            digitlist = self.checkForDigits(tracked)
            if False not in digitlist:
                licenses[product] = self.addLists(licenses[product], tracked)  # add tracked to list
            else:
                licenses[product] = tracked

        return dict(licenses)

    def checkForDigits(self, arg):
        return list(map(lambda x: str(x).encode('utf-8').isdigit(), arg))

    def parseUsers(self, tablerows, tracklist):
        """ note: we're using input rows instead of a table because of the
			erroneous result from urllib/beautifulsoup with an ill parsed POST
			result
		"""

        # if we're passed nothing, return
        if not tablerows:
            return

        header = tablerows[0].find_all('td')
        tablerows = tablerows[1:]

        header = map(self.stripHtml, header)
        pos = map(lambda x: header.index(x), tracklist)

        licenses = defaultdict(list)

        for row in tablerows:
            cols = row.find_all('td')
            product = str(cols[0].string)
            tracked = list(map(lambda i: cols[i].string.encode('utf-8'), pos))

            if not tracked in licenses[product]:
                licenses[product].append(tracked)

        prelim = dict(licenses)
        sorted_lic = defaultdict(list)

        # aggregate list of users for products
        for k, v in prelim.items():
            for lic in v:
                user = lic[2]
                sorted_lic[k].append(user)
            # find unique users
            users_unique = list(set(sorted_lic[k]))
            # condense the usage into a more readable format
            sorted_lic[k] = map(lambda x: str(x) + " (" + str(sorted_lic[k].count(x)) + ")", users_unique)

        return dict(sorted_lic)

    def printLicTable(self, keyvals, header):

        # set width length based on longest key
        width = len(max(keyvals.keys(), key=len))
        padding = 2 * " "
        row_format = ""

        # workaround for python 2.6
        for i in range(0, len(header)):
            row_format += "{" + str(i) + ":>" + str(width) + "}"

        # add and change format for last column for user list
        # want length of longest user list
        values = keyvals.values()
        values_zip = list(zip(*values))
        col_users = values_zip[len(values_zip) - 1]
        user_width = len(max(col_users, key=len))
        row_format += padding + "{" + str(len(header)) + ":<" + str(user_width) + "}"

        output_header = row_format.format("", *header)
        text_header_length = len(output_header)

        text_foundry = "The Foundry License Usage"
        text_time = datetime.datetime.now().strftime("%A, %B %d %Y %I:%M%p")

        text_border_format = "+{0:-^" + str(text_header_length) + "}+"
        text_title_format = "+{0:^" + str(text_header_length) + "}+"

        output_border = text_border_format.format("-")
        output_title_name = text_title_format.format(text_foundry)
        output_title = [output_border, output_title_name, output_border]

        map(pprint, output_title)  # print title

        print row_format.format("", *header)  # print column headers
        for key, vals in keyvals.iteritems():
            output = row_format.format(key, *vals)
            print output

        output_footer_name = text_title_format.format(text_time)
        output_footer = [output_border, output_footer_name, output_border]
        map(pprint, output_footer)  # print footer

    def retUrl(self, url, **kwargs):

        req = urllib2.Request(url)
        print url
        if 'data' in kwargs:
            form_data = urllib.urlencode(kwargs['data'])
            req.add_data(form_data)

        if 'header' in kwargs:
            header_data = urllib.urlencode(kwargs['header'])
            req.add_header(kwargs)

        try:
            print req
            rlm_response = urllib2.urlopen(req)

        except URLError as e:
            if hasattr(e, 'reason'):
                print 'We failed to reach a server.'
                print 'Reason: ', e.reason
            elif hasattr(e, 'code'):
                print 'The server couldn\'t fulfill the request.'
                print 'Error code: ', e.code
        else:
            return rlm_response.read()

    def stripHtml(self, html):
        soup = BeautifulSoup(str(html.string), 'html.parser')
        return soup.get_text().encode('utf-8')

    def addLists(self, *args):
        return [sum(x) for x in zip(*args)]


    def run(self, *args, **kwargs):
        super(App, self).run(*args, **kwargs)

        rlm_server = "http://groovy.corp.jauntvr.com:4102/goforms"
        rlm_status = "rlmstat_isv"
        rlm_usage = "rlmstat_lic_process"

        # what to track
        tracked_stat = ["count", "soft lim", "inuse"]

        tracked_use = ["Pool", "Ver", "user", "host", "PID", "req ver", "# lic"]

        rlm_stat_req = rlm_server + "/" + rlm_status
        rlm_use_req = rlm_server + "/" + rlm_usage

        form_status_vals = {'wb': 'rlmstat',
                            'isv': 'foundry',
                            'instance': 0,
                            'ok': 'foundry'}

        form_usage_vals = {'host': '',
                           'isv': 'foundry',
                           'product': '',
                           'user': '',
                           'password': None,
                           'ok': 'GET License Usage',
                           'instance': 0}

        rlm_stat_html = self.retUrl(rlm_stat_req, data=form_status_vals)
        rlm_use_html = self.retUrl(rlm_use_req, data=form_usage_vals)

        soup_stat = BeautifulSoup(rlm_stat_html, 'html.parser')
        soup_use = BeautifulSoup(rlm_use_html, 'html.parser')

        # get list of licenses used
        table_html_lic = soup_stat.find_all('table')[2]
        licenses = self.parseLicenses(table_html_lic, tracked_stat)

        #pprint(soup_use)

        # get list of users
        tracked_stat.append('users')
        table_html_use = soup_use.find_all('tr')
        users = self.parseUsers(table_html_use, tracked_use)

        # add users to printout
        for product in licenses:
            if users:
                if product in users:
                    users[product].sort()
                    licenses[product].append(", ".join(users[product]))
                else:
                    licenses[product].append("")
            else:
                licenses[product].append("")

        self.printLicTable(licenses, tracked_stat)


class TestApp(unittest.TestCase):
    def setUp(self):
        """ Work to do before each test. """
        self.app = App()

    def tearDown(self):
        """ Work to do after each test. """
        pass

    def testRun(self):
        """ Run a test of the whole app. """
        assert self.app is not None

    def testFoo(self):
        """ Run a test called "Foo" """
        assert False == True


if __name__ == "__main__":
    import sys

    if "--runtests" in sys.argv:
        unittest.main()
